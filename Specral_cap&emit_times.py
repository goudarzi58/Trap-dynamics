###

"""
This program is written for simulating the spectral nature
of capture and emission time constants of plasmonic hot electrons
generated by the plasmon decay in metal when being trapped in a
interface state or a border trap

"""
import numpy as np
import scipy as sp
import matplotlib.pylab as plt
from scipy.integrate import quad

#  ### Constant Values

h_bar = 6.5821 * 10-16 ## in eV.s
##h_bar = 1  ### in a.u.
kb = 8.617333262145*1e-5  #Boltzman constant in eV/K
nm = 0.0529177
Ec_ox = 4.3 ## Potential barrier for electrons related to the Fermi level of the gold and in eV
Ev_ox = 4.7 ## Potential barrier for holes related to the Fermi level of the gold and in eV
Eg_ox = 9 ## Band gap OF SiO2 in eV
Ecnl_ox = 4.5 ## Charge neutrality level in eV 
m_Au = 1.1 # ## effective mass of e in Au in atomic units (in atomic units)
m_ox = 0.42 # ## effective mass of e in SiO2 (in atomic units)

# We asume that all
theta_max = 1  ### ????+
theta_in = np.array([0, np.pi/36, np.pi/18, np.pi/12, np.pi/9, np.pi/6, np.pi/4, np.pi/3])
##phi_in =  
A = 10
dt = 2 
# ###Input data
T = np.array([300])
kT = kb*T  ### the thermal energy in eV
Ehot = np.array([2]) ## the energy of hot-electron in eV
E_T = np.array([1]) ## the trap level in eV
px = np.sqrt(m_Au*Ehot*np.sin(theta_in))/h_bar ### to simplify the calculations
py=px    ### to simplify the calculations

### ===>> Ehot_parl = Ehot* np.sin(theta_in[0])**2  ###not sure if it should be used
E_parl = E_T   ### Parralel energy# it ommites 
deltaE = Ehot-E_T  ## The energy differnce between Hot electron and the oxide trap
##print('kT', kT)
h_omegap = np.array([30, 20, 10])*1e-3 ## The phonon energy in eV
S = np.array([33, 50, 100])   ###  HR-factor
deltaE = Ehot-E_T

n_occ = 1/(np.exp(h_omegap/kT[0]))  #   ### the phonon occupation function

print('n_occ:', n_occ)

#   ### The number of emitted phonons of energy h_omega in the transition
#   ### of a hot_e with energy of Ehot into the trap of E_T
P_Eh = np.round(((deltaE)+E_parl)/h_omegap)
print('P_Eh:', P_Eh)
#   ### xi factor
xi = 2*S* np.sqrt(n_occ * (n_occ+1))
print('xi:', xi)
#   ### chi factor
chi = (P_Eh)**2 + xi**2
print('chi:', chi)
xx = np.float_power((1/5), 2)
#   ### The auxilary function
ag = 1/(np.sqrt(2*np.pi)*h_omegap)
bg = np.float_power(1/chi, 0.25)
cg = np.float_power(xi/(P_Eh + np.sqrt(chi)), P_Eh)
dg = np.exp(np.sqrt(chi) - (2*n_occ+1)*S + (P_Eh*h_omegap)/2*kT)
G_deltaE = ag*bg*cg*dg
##G_deltaE = (1/(np.sqrt(2*np.pi)*h_omega))*(np.float_power(1/chi, 0.25))*(
##            np.float_power((xi/(P_Eh + np.sqrt(chi)), P_Eh)) *(
##            np.exp(np.sqrt(chi) - (2*n_occ+1)*S + (P_Eh*h_omegap)/2*kT))

print('G_deltaE:', G_deltaE)

# ## Calculating the trap activation energy
E_B = (Ehot - E_T - S*h_omegap)**2/(4*S*h_omegap)  ## Trap thermal barrier energy
print('E_B: ', E_B)
# ## The Relaxation energy (should be calculated from S and h_omegap)
E_rlx = (E_T + S*h_omegap)**2/(4*S*h_omegap)
print('E_rlx: ', E_rlx)
# ### redius of solid sphere shape defect in Oxide
R_T = 0.5*h_bar*(1/np.sqrt(2*m_ox*(Ec_ox-E_T)))
print('R_T*nm:', R_T*nm)
a_T = 1.612 * R_T   ### This the side length of the cube that surround the spher
print('a_T :', a_T )
V_T = a_T**3  ## The volume of trap
print('V_T :', V_T)
# ### Building the wave function of tunneling hot electron from metal to oxide
theta = np.array([2]) # ### in degrees  ???????
p_rel = np.sqrt(2*m_ox*(Ec_ox - Ehot)/h_bar**2) ## the extra momentum that an electron needs to reach Ec of oxide and be considered free

pz = np.sqrt(m_Au*Ehot*np.cos(theta_in))/h_bar
### H_e in the paper: This the damping factor for WF of the electron
p_dmp = np.sqrt(p_rel**2+px**2+py**2) # ### kx and ky are the in plane momentums of the tunneling elecron inside the oxide
print('p_dmp:', p_dmp[0])
### The integral parameters:
q_xm = np.sqrt(2)/(2*R_T)
q_zm = q_xm
print('q_zm:', q_zm)
deltax = 2*q_xm/2000
print('deltax:', deltax)
qx = np.linspace(-q_xm, q_xm+deltax, num=2000)
##print('qx:', qx)
deltaz = 2*q_xm/2000
qz = np.linspace(-q_zm, q_zm+deltaz, num=2000)
##print('qz:', qz)
##########################################
      
def I_px(qx):
    return abs(2*np.sin(0.5*(px[0]+qx)*a_T)/(px[0]+qx))**2
I_px = np.vectorize(I_px)
i_px = np.sum(I_px(qx))*deltax

# #########

def I_pz(qz):
    return abs(2j*np.sin((1j*(pz[0]+qz)-p_dmp[0])*a_T/2)/(1j*(pz[0]+qz)-p_dmp[0]))**2
I_pz = np.vectorize(I_pz)
i_pz = np.sum(I_pz(qz))*deltaz
print('i_pz', i_pz)
############################################

def I_x(qx):
    return abs(2*np.sin(0.5*(px[0]+qx)*a_T[0])/qx)**2
I_x = np.vectorize(I_x)
i_x = np.sum(I_x(qx))*deltax
print('i_x', i_x)
##### #########
def I_z(qz):
    return abs(2*np.sin(0.5*(pz[0]+qz)*a_T[0])/qz)**2
I_z = np.vectorize(I_z)
i_z = np.sum(I_z(qz))*deltaz
print('i_z', i_z)
############################################

### #################
c1 = 2*(pz[0]**2/(p_dmp[0]**2+pz[0]**2))
c2 = 2*(V_T*(h_omegap[0]**2)/A)

### The transfer matrix element
Tm = S[0]*c1*c2*np.exp(-1*p_dmp[0]*dt)*((i_px*i_pz)/(i_x*i_z))
print('Tm:', Tm)

# ### The multi-phonon emission probability of a hot-electron with energy E_hot 
# ### to be captured by an interface trap

Wmp_Eh = (np.pi/h_bar)*S[0]*Tm*((1-(P_Eh/S[0]))**2)*G_deltaE
print('Wmp_Eh:', Wmp_Eh)
# ### The surface capture rate for electrons with energy of E_Hot

c_Eh = Wmp_Eh * A

 ### The hot-electron concentration per unit area having the minemum required
 ### energy: E_hot = E_T + E_B










