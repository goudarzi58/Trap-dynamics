###

"""
This program is written for simulating the spectral nature
of capture and emission time constants of plasmonic hot electrons
generated by the plasmon decay in metal when being trapped in a
interface state or a border trap

"""
import numpy as np
import scipy as sp
import matplotlib.pylab as plt
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.ticker as mticker
#  ### Constant Values

#h_bar = 6.5821 * 10-16 ## in eV.s
h_bar = 1  ## in atomic Units
##h_bar = 1  ### in a.u.

nm = 0.0529177
Hartree = 1/27.2114
kb = (8.617333262145*1e-5)*Hartree  #Boltzman constant in Hartree/K
#### The Fermi level is the reference
Ec_ox = 4.3*Hartree ## Potential barrier for electrons related to the Fermi level of the gold and in eV
phiB = Ec_ox
Ev_ox = 4.7*Hartree ## Potential barrier for holes related to the Fermi level of the gold and in eV
Eg_ox = 9*Hartree ## Band gap OF SiO2 in eV
Ecnl_ox =-0.2*Hartree # Ev+4.5 ## Charge neutrality level in eV 
m_Au = 1.1 # ## effective mass of e in Au in atomic units (in atomic units)
m_ox = 0.42 # ## effective mass of e in SiO2 (in atomic units)
lambada = 425  ## nm
dm = 15*(1/0.05291772490001) ### the thickness of Au film in nm
epsd = 2.1704
epsm = np.complex(-1.6954, 5.6710) ### it is 
# We asume that all
theta_max = 1  ### ????+
##theta_in = np.array([0, np.pi/36, np.pi/18, np.pi/12, np.pi/9, np.pi/6, np.pi/4, np.pi/3])
##phi_in =
theta_in = 0
#######################:::: Area:
### n_LRP from ref[73]:
def nlrp(x):
    n_LRP = np.sqrt(epsd + (((np.pi*x)/(lambada*epsm))*(epsd-epsm)*epsd)**2)
    return n_LRP
n_LRP = nlrp(dm).real
lambada_LRP = lambada/n_LRP*(1/0.05291772490001)
A = 25* (lambada_LRP**2) #### Length of the film is 5 times of LRP wavelength in a.u.
dt = 0.05 *(1/0.05291772490001) ### in a.u.
# ###Input data
T = np.array([70, 72.5, 75, 77.5, 80, 82.5, 85, 87.5, 90, 92.5, 95, 97.5, 100])
kT = kb*T  ### the thermal energy in eV
Ehot = np.array([1.3])*Hartree ## the energy of hot-electron in eV
E_T = 1*Hartree ## the trap level in eV
px = np.sqrt(m_Au*Ehot*np.sin(theta_in))/h_bar ### to simplify the calculations
py=px    ### to simplify the calculations

### ===>> Ehot_parl = Ehot* np.sin(theta_in[0])**2  ###not sure if it should be used
E_parl = E_T   ### Parralel energy# it ommites 
deltaE = Ehot-E_T  ## The energy differnce between Hot electron and the oxide trap
##print('kT', kT)
h_omegap = 20*1e-3*Hartree  #Boltzman constant in eV/K ## The phonon energy in eV
S = 50   ###  HR-factor
deltaE = Ehot-E_T

n_occ = 1/(np.exp(h_omegap/kT))  #   ### the phonon occupation function

print('n_occ:', n_occ)

#   ### The number of emitted phonons of energy h_omega in the transition
#   ### of a hot_e with energy of Ehot into the trap of E_T
P_Eh = np.round(((deltaE)+E_parl)/h_omegap)
print('P_Eh:', P_Eh)
#   ### xi factor
xi = 2*S* np.sqrt(n_occ * (n_occ+1))
print('xi:', xi)
#   ### chi factor
chi = (P_Eh)**2 + xi**2
print('chi:', chi)
xx = np.float_power((1/5), 2)
#   ### The auxilary function
ag = 1/(np.sqrt(2*np.pi)*h_omegap)
bg = np.float_power(1/chi, 0.25)
cg = np.float_power(xi/(P_Eh + np.sqrt(chi)), P_Eh)
dg = np.exp(np.sqrt(chi) - (2*n_occ+1)*S + (P_Eh*h_omegap)/2*kT)
G_deltaE = ag*bg*cg*dg
##G_deltaE = (1/(np.sqrt(2*np.pi)*h_omega))*(np.float_power(1/chi, 0.25))*(
##            np.float_power((xi/(P_Eh + np.sqrt(chi)), P_Eh)) *(
##            np.exp(np.sqrt(chi) - (2*n_occ+1)*S + (P_Eh*h_omegap)/2*kT))

print('G_deltaE:', G_deltaE)

# ## Calculating the trap activation energy
E_B = (Ehot - E_T - S*h_omegap)**2/(4*S*h_omegap)  ## Trap thermal barrier energy
print('E_B: ', E_B/Hartree)
# ## The Relaxation energy (should be calculated from S and h_omegap)
E_rlx = (E_T + S*h_omegap)**2/(4*S*h_omegap)
print('E_rlx: ', E_rlx)

# ### redius of solid sphere shape defect in Oxide
R_T = (0.5*h_bar)/np.sqrt(2*m_ox*(Ec_ox-E_T))
print('R_T:', R_T)
print('***',h_bar, m_ox,Ec_ox ,E_T)
a_T = 1.612 * R_T   ### This the side length of the cube that surround the spher
print('a_T :', a_T )
V_T = a_T**3  ## The volume of trap
print('V_T :', V_T)
# ### Building the wave function of tunneling hot electron from metal to oxide
theta = np.array([2]) # ### in degrees  ???????
p_rel = np.sqrt(2*m_ox*(phiB - Ehot)/(h_bar**2)) ## the extra momentum that an electron needs to reach Ec of oxide and be considered free

pz = np.sqrt(m_Au*Ehot*np.cos(theta_in))/h_bar
### H_e in the paper: This the damping factor for WF of the electron
p_dmp = np.sqrt(p_rel**2+px**2+py**2) # ### kx and ky are the in plane momentums of the tunneling elecron inside the oxide
print('p_dmp:', p_dmp[0])
### The integral parameters:
q_xm = np.sqrt(2)/(2*R_T)
q_zm = q_xm
print('q_zm:', q_zm)
deltax = 2*q_xm/2000
print('deltax:', deltax)
qx = np.linspace(-q_xm, q_xm+deltax, num=2000)
##print('qx:', qx)
deltaz = 2*q_xm/2000
qz = np.linspace(-q_zm, q_zm+deltaz, num=2000)
##print('qz:', qz)
##########################################
      
def I_px(qx):
    return abs(2*np.sin(0.5*(px[0]+qx)*a_T)/(px[0]+qx))**2
I_px = np.vectorize(I_px)
i_px = np.sum(I_px(qx))*deltax
print('i_px', i_px)

# #########

def I_pz(qz):
    return abs(2j*np.sin((1j*(pz[0]+qz)-p_dmp[0])*a_T/2)/(1j*(pz[0]+qz)-p_dmp[0]))**2
I_pz = np.vectorize(I_pz)
i_pz = np.sum(I_pz(qz))*deltaz
print('i_pz', i_pz)
############################################

def I_x(qx):
    return abs(2*np.sin(0.5*qx*a_T)/qx)**2
I_x = np.vectorize(I_x)
i_x = np.sum(I_x(qx))*deltax
print('i_x', i_x)
##### #########
def I_z(qz):
    return abs(2*np.sin(0.5*qz*a_T)/qz)**2
I_z = np.vectorize(I_z)
i_z = np.sum(I_z(qz))*deltaz
print('i_z', i_z)
############################################

### #################
c1 = 2*(pz[0]**2/(p_dmp[0]**2+pz[0]**2))
print('c1:', c1)
print('A', A)
c2 = 2*(V_T*(h_omegap**2)/(A))
print('c2:', c2)
### The transfer matrix element
Tm = S*c1*c2*np.exp(-2*p_dmp[0]*dt)*(((i_px**2)*i_pz)/((i_x**2)*i_z))
print('Tm:', Tm)
Tm1 = (4*np.pi*(h_bar**4)/((m_ox**2)*A*dm))*(p_rel*(pz[0]**2)/(p_dmp[0]**2+pz[0]**2))*np.exp(-2*p_dmp[0]*dt)
print('Tm1:', Tm1)
# ### The multi-phonon emission probability of a hot-electron with energy E_hot 
# ### to be captured by an interface trap
print('wwww', 1-(P_Eh/S))
Wmp_Eh = (np.pi/h_bar)*S*Tm*((1-(P_Eh/S))**2)*G_deltaE
print('Wmp_Eh:', Wmp_Eh)
# ### The surface capture rate for electrons with energy of E_Hot

c_Eh = Wmp_Eh * A
print('c_Eh', c_Eh)
 ### The hot-electron concentration per unit area having the minemum required
 ### energy: E_hot = E_T + E_B
N0e0 = 3e17
Ne0 = N0e0*(1e27)*((0.05291772490001)**3)
print('Ne0:', Ne0)
t0p = 1/(c_Eh*Ne0)

print('trap time', t0p)



##########################################
fig, ax = plt.subplots()
Ls = ['--', '-.', ':', '-']  
#
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive', 'darkorange', 'forestgreen', 'navy','seagreen', 'lime', 'peru', 'darkred', 'yellow']
##for i in range(nBands):
##    plt.plot(z, bands[i], color=colors[i], linewidth=3, ls=Ls[i])
##
ax.plot(T, t0p)
f = mticker.ScalarFormatter(useOffset=False, useMathText=True)
g = lambda x,pos : "${}$".format(f._formatSciNotation('%1.10e' % x))
plt.gca()

plt.plot(T, t0p, color=colors[0], linewidth=3, ls=Ls[0])
ax=plt.gca()
ax.xaxis.set_minor_formatter(mticker.ScalarFormatter())
##ax.set_xscale('log')
ax.set_yscale('log')
##
plt.xlabel('T (K)', fontweight="bold")
##plt.xlim([0, 6.8])
##plt.ylim(-7, 7)
plt.ylabel('Trap time (s) ', fontweight="bold")
##mpl.rcParams.update({'font.size': 12})#, {'font.weight': 'bold'})
####plt.xticks([0.0, 1.5, 2.3, 3.1, 4.9, 6.8],
####           [r"$\Gamma$", r"$X$", r"$W$", r"$L$", r"$\Gamma$", r"$K$"], fontweight="bold", fontsize=16)
#####plt.legend(loc='lower center')
##plt.rcParams['axes.labelweight'] = 'bold'
##plt.rcParams['title.labelweight'] = 'bold'
plt.title('Trap time vs T', fontweight="bold")
plt.savefig('Trap time vs T.pdf', dpi=1000)
plt.show()



